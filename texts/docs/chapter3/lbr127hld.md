# # フォトリフレクタ(LBR-127HLD)の使い方

このセクションでは、LBR-127HLDというフォトリフレクタの使い方を学びます。フォトリフレクタは、赤外線LEDとフォトトランジスタを組み合わせたセンサーで、物体の有無や色の違い（反射率の違い）を検出するために使われます。ロボットのライントレースなどでよく利用される、基本的かつ重要なセンサーです。

## 動作原理とアナログ信号

1.  **発光と受光**:
    -   内蔵された赤外線LEDから赤外光が照射されます。
    -   その光が物体に反射し、戻ってきた光をフォトトランジスタが受け取ります。

2.  **フォトトランジスタ**:
    -   フォトトランジスタは、受光した光の強さに応じて流れる電流が変化する半導体です。
    -   たくさんの光を受け取ると、たくさんの電流を流します（抵抗が小さくなる）。
    -   光が少ないと、電流はほとんど流れません（抵抗が大きくなる）。

3.  **アナログ電圧の取得**:
    -   この電流の変化を電圧の変化としてマイコンで読み取るために、**分圧回路**を構成します。
    -   フォトトランジスタと、もう一つの**抵抗（プルダウン抵抗）**でマイコンの電源電圧（3.3V）を分圧し、その中間の電圧をマイコンのアナログ入力ピンで読み取ります。
    -   白い面のように反射率が高い物体が近づくと、フォトトランジスタに多くの光が入り、たくさん電流が流れます。その結果、アナログピンで読み取る電圧は低くなります。
    -   黒い面のように反射率が低い物体が近づくと、反射光が少なく、フォトトランジスタにはあまり電流が流れません。その結果、アナログピンで読み取る電圧は高くなります。

このように、連続的に変化する電圧の値を**アナログ信号**と呼びます。マイコンは**ADC (Analog to Digital Converter)** という機能を使って、このアナログ電圧をデジタル値に変換して処理します。

## 回路図と接続

フォトリフレクタのVCCとGNDを電源に接続し、OUTピンをRaspberry Pi Picoのアナログ入力ピン（ADCが使えるピン、例えばGP26, GP27, GP28）に接続します。
OUTピンとGNDの間に、**10kΩ**程度のプルダウン抵抗を接続します。この抵抗値は、センサーの感度に影響します。

*（ここに `circuits.drawio` で作成したフォトリフレクタの回路図を挿入）*

| フォトリフレクタ | Raspberry Pi Pico |
| :--------------- | :---------------- |
| VCC              | 3.3V (OUT)        |
| GND              | GND               |
| OUT              | GP26 (ADC0)       |

**注意**: OUTピンとGNDの間に10kΩの抵抗を接続してください。

## プログラム

以下のプログラムは、GP26ピンからフォトリフレクタの値を読み取り、シリアルモニタに表示します。まずはこのコードを書き込んで、センサーの前に白や黒のものをかざし、値がどう変化するか観察してみましょう。

```cpp
#define SENSOR_PIN 26 // フォトリフレクタのOUTを接続するピン (ADC0)

void setup() {
    Serial.begin(115200); // シリアル通信の開始
    // アナログピンは pinMode の設定は不要
}

void loop() {
    // analogReadでセンサーの値を読み取る (0〜4095の範囲)
    int sensorValue = analogRead(SENSOR_PIN);

    // 読み取った値をシリアルモニタに表示
    Serial.print("Sensor Value: ");
    Serial.println(sensorValue);

    delay(500); // 0.5秒待機
}
```

### コードの解説
-   `#define SENSOR_PIN 26`: センサーを接続したピンを定数として定義します。PicoのアナログピンはGP26, 27, 28です。それぞれADC0, 1, 2に対応します。
-   `analogRead(SENSOR_PIN)`: 指定したアナログピンの電圧を読み取ります。Raspberry Pi PicoのADCは12ビットの分解能を持つため、0Vから3.3Vの電圧を**0から4095**のデジタル値に変換して返します。Arduino Unoなどは10ビット（0-1023）なので、マイコンによって分解能が違う点に注意が必要です。
-   白い紙と黒いマジックなどを使って、センサーの前にかざすものを変えると、シリアルモニタに表示される値が大きく変化することを確認してみましょう。この値の差を利用して、ライントレースロボットは線を認識します。

### ノイズ対策：より安定した値を得るために

シリアルモニタの値をじっと見ていると、センサーの前にかざすものを変えていないのに、値が細かく変動（ふらつく）ことに気づくでしょう。これはセンサーの故障ではなく、電源や周囲の環境から来る**ノイズ**の影響です。

実用的なシステムでは、このような不安定な生の値をそのまま使うことは稀です。最も簡単で効果的なノイズ対策は、**複数回測定してその平均値を使う**ことです。これを**移動平均フィルター**と呼びます。

さきほどのコードを、移動平均フィルターを使うように改造してみましょう。

```diff
--- a/src/reflector/main.ino
+++ b/src/reflector/main.ino
@@ -4,13 +4,21 @@
     Serial.begin(115200); // シリアル通信の開始
     // アナログピンは pinMode の設定は不要
 }
 
+long readAverage(int pin, int samples) {
+    long sum = 0;
+    for (int i = 0; i < samples; i++) {
+        sum += analogRead(pin);
+        delay(1); // わずかな時間をおいてサンプリング
+    }
+    return sum / samples;
+}
+
 void loop() {
     // analogReadでセンサーの値を読み取る (0〜4095の範囲)
-    int sensorValue = analogRead(SENSOR_PIN);
+    int sensorValue = readAverage(SENSOR_PIN, 10); // 10回の測定値の平均を取る
 
     // 読み取った値をシリアルモニタに表示
     Serial.print("Sensor Value: ");
     Serial.println(sensorValue);
 
     delay(500); // 0.5秒待機
 }
```

`loop`の中から値を1回だけ読んでいた処理を、10回読んで平均を返す`readAverage`関数に置き換えました。こうすることで、突発的なノイズの影響が緩和され、より安定した測定値が得られるようになります。

<details>
<summary><b>横道：</b>ADCの限界</summary>

`analogRead`は魔法ではありません。現実世界の物理的な制約を受けます。

- **量子化誤差**: 12bitのADCは、3.3Vの電圧範囲を4096段階で表現します。つまり、`3.3V / 4096 = 0.0008V (0.8mV)` という非常に細かい単位でしか電圧を測定できません。この最小単位より小さい電圧の変化は検出できず、誤差となります。これを**量子化誤差**と呼びます。

- **ノイズ**: センサーからのアナログ信号は、周囲の電磁波や電源の変動など、様々な要因でノイズが乗ります。`analogRead`の値を何度も連続で読んでみると、値が微妙にふらつくのが分かるはずです。これはセンサーの故障ではなく、物理的な現象です。

- **サンプリングレート**: `analogRead`には、電圧を測定するためのわずかな時間がかかります。PicoのADCは非常に高速（最大500,000サンプル/秒）ですが、`analogRead`関数自体はそこまで速くありません。非常に高速な信号の変化を捉えようとすると、一部を取りこぼす可能性があります（**エリアシング**）。

</details>


このセクションでは、LBR-127HLDというフォトリフレクタの使い方を学びます。フォトリフレクタは、赤外線LEDとフォトトランジスタを組み合わせたセンサーで、物体の有無や色の違い（反射率の違い）を検出するために使われます。ロボットのライントレースなどでよく利用される、基本的かつ重要なセンサーです。

## 動作原理とアナログ信号

1.  **発光と受光**:
    -   内蔵された赤外線LEDから赤外光が照射されます。
    -   その光が物体に反射し、戻ってきた光をフォトトランジスタが受け取ります。

2.  **フォトトランジスタ**:
    -   フォトトランジスタは、受光した光の強さに応じて流れる電流が変化する半導体です。
    -   たくさんの光を受け取ると、たくさんの電流を流します（抵抗が小さくなる）。
    -   光が少ないと、電流はほとんど流れません（抵抗が大きくなる）。

3.  **アナログ電圧の取得**:
    -   この電流の変化を電圧の変化としてマイコンで読み取るために、**分圧回路**を構成します。
    -   フォトトランジスタと、もう一つの**抵抗（プルダウン抵抗）**でマイコンの電源電圧（3.3V）を分圧し、その中間の電圧をマイコンのアナログ入力ピンで読み取ります。
    -   白い面のように反射率が高い物体が近づくと、フォトトランジスタに多くの光が入り、たくさん電流が流れます。その結果、アナログピンで読み取る電圧は低くなります。
    -   黒い面のように反射率が低い物体が近づくと、反射光が少なく、フォトトランジスタにはあまり電流が流れません。その結果、アナログピンで読み取る電圧は高くなります。

このように、連続的に変化する電圧の値を**アナログ信号**と呼びます。マイコンは**ADC (Analog to Digital Converter)** という機能を使って、このアナログ電圧をデジタル値に変換して処理します。

## 回路図と接続

フォトリフレクタのVCCとGNDを電源に接続し、OUTピンをRaspberry Pi Picoのアナログ入力ピン（ADCが使えるピン、例えばGP26, GP27, GP28）に接続します。
OUTピンとGNDの間に、**10kΩ**程度のプルダウン抵抗を接続します。この抵抗値は、センサーの感度に影響します。

*（ここに `circuits.drawio` で作成したフォトリフレクタの回路図を挿入）*

| フォトリフレクタ | Raspberry Pi Pico |
| :--------------- | :---------------- |
| VCC              | 3.3V (OUT)        |
| GND              | GND               |
| OUT              | GP26 (ADC0)       |

**注意**: OUTピンとGNDの間に10kΩの抵抗を接続してください。

## プログラム

以下のプログラムは、GP26ピンからフォトリフレクタの値を読み取り、シリアルモニタに表示します。

```cpp
#define SENSOR_PIN 26 // フォトリフレクタのOUTを接続するピン (ADC0)

void setup() {
    Serial.begin(115200); // シリアル通信の開始
    // アナログピンは pinMode の設定は不要
}

void loop() {
    // analogReadでセンサーの値を読み取る (0〜4095の範囲)
    int sensorValue = analogRead(SENSOR_PIN);

    // 読み取った値をシリアルモニタに表示
    Serial.print("Sensor Value: ");
    Serial.println(sensorValue);

    delay(500); // 0.5秒待機
}
```

### コードの解説
-   `#define SENSOR_PIN 26`: センサーを接続したピンを定数として定義します。PicoのアナログピンはGP26, 27, 28です。それぞれADC0, 1, 2に対応します。
-   `analogRead(SENSOR_PIN)`: 指定したアナログピンの電圧を読み取ります。Raspberry Pi PicoのADCは12ビットの分解能を持つため、0Vから3.3Vの電圧を**0から4095**のデジタル値に変換して返します。Arduino Unoなどは10ビット（0-1023）なので、マイコンによって分解能が違う点に注意が必要です。
-   白い紙と黒いマジックなどを使って、センサーの前にかざすものを変えると、シリアルモニタに表示される値が大きく変化することを確認してみましょう。この値の差を利用して、ライントレースロボットは線を認識します。

<details>
<summary><b>横道：</b>ADCの限界とノイズ対策</summary>

`analogRead`は魔法ではありません。現実世界の物理的な制約を受けます。

- **量子化誤差**: 12bitのADCは、3.3Vの電圧範囲を4096段階で表現します。つまり、`3.3V / 4096 = 0.0008V (0.8mV)` という非常に細かい単位でしか電圧を測定できません。この最小単位より小さい電圧の変化は検出できず、誤差となります。これを**量子化誤差**と呼びます。

- **ノイズ**: センサーからのアナログ信号は、周囲の電磁波や電源の変動など、様々な要因でノイズが乗ります。`analogRead`の値を何度も連続で読んでみると、値が微妙にふらつくのが分かるはずです。これはセンサーの故障ではなく、物理的な現象です。

- **サンプリングレート**: `analogRead`には、電圧を測定するためのわずかな時間がかかります。PicoのADCは非常に高速（最大500,000サンプル/秒）ですが、`analogRead`関数自体はそこまで速くありません。非常に高速な信号の変化を捉えようとすると、一部を取りこぼす可能性があります（**エリアシング**）。

#### 簡単なノイズ対策：移動平均フィルター
実用的なシステムでは、生の値（Raw Value）をそのまま使うことは稀です。最も簡単なノイズ対策は、複数回測定して平均を取ることです。

```cpp
int readAverage(int pin, int samples) {
    long sum = 0;
    for (int i = 0; i < samples; i++) {
        sum += analogRead(pin);
        delay(1); // わずかな時間をおいてサンプリング
    }
    return sum / samples;
}

void loop() {
    int sensorValue = readAverage(SENSOR_PIN, 10); // 10回の測定値の平均を取る
    Serial.println(sensorValue);
    delay(500);
}
```
これを**移動平均フィルター**と呼び、多くのセンサー処理で使われる基本的なテクニックです。

</details>

